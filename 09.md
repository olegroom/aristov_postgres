Создаю таблица с колонкой jsonb 
```postgresql
create table if not exists fast_json
(
    i          serial primary key,
    emp_id     integer,
    custom_doc jsonb
);
```

Я сначала не понял, почему поиск по ключу при миллионе записей такой быстрый  
Поэтому залили 4 ляма записей.  
Важным тут нюансом является то, что рандомными мы должны делать ключи в jsonb объекте, ибо индекс строится как раз для ключей  
Поэтому при заполнении данных, надо было генерить рандомный как раз КЛЮЧ

```postgresql
do
$$
    begin
        for i in 1..4000000
            loop
                insert into fast_json (emp_id, custom_doc)
                values (i, json_build_object('key' || (random() * 100000)::text, 'no matter value',
                                             'name', 'autojob',
                                             'seller_id', 3001));
            end loop;
    end;
$$;
```

После заполнения таблицы я посмотрел сколько длится поиск по ключу
```postgresql
select *
from fast_json
where custom_doc ? 'key94921.93686364725';
```
> В среднем 700 мс

Далее создал индекс по внешнему ключу

```postgresql
create index on fast_json USING gin (custom_doc);
```

И выполнил запрос еще раз. Получил приятный результат
> 66 мс

В общем десятикратное ускорение  
Через pg_class нашел oid тоаст таблицы для моей таблицы fast_json. И по нему 
посмотрел размер файла. Увидел 0, значит тоаст таблица не была задействована.  
Я предполагаю, что это связано с маленьким размером json, который я вставлял  
В общем там можно еще на несколько дней зависнуть, непаханное поле с этим toast,
поэтому я наверное не смогу пока этим заняться, сделал что успел 
